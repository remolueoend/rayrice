#!/usr/bin/env bash

set -e

help_text='
This script pulls the description of the current merge request (based on the current branch),
stores it in a temporary file and opens it in $EDITOR.
After the editor exists, the content of the file is uploaded as the new description
of the merge request.
Currently, the markdown description is converted to ORG before editing and converted back
before it is uploaded to Gitlab.
The script looks for a file "editmrrc" in the current directory and all parent directories
up to the root directory. It must exist and contain the gitlab path of the current project
as a single string, e.g.: mygroup/myproject or myusername/myproject

Author: remolueoend

Dependencies:
* git
* graphqurl: https://github.com/hasura/graphqurl
* jq
* pandoc (for converting descriptions to ORG)

Variables:
DEBUG [=unset]  : when set, xtrace is activated.
EDITMR_ENDPOINT [=https://gitlab.com/api/graphql]: The graphql endpoint of your Gitlab instance.
EDITMR_PROJECT  : The Gitlab project path, e.g: mygroup/project or myusername/project
EDITMR_TOKEN    : your personal Gitlab access token. Can be generated via the profile page on your Gitlab instance
EDITOR [=vim]   : The editor to be used. Needs to block until closed (e.g. "emacs", "vim", ...)

Usage:
EDITMR_TOKEN=<your_token> EDITMR_PROJECT=<project_path> [EDITMR_ENDPOINT=<endpoint>] [DEBUG=1] editmr

Comments:
1. Why does this script make use of environment variables instead of accepting values as arguments?
   This approach allows storing the project dependent parameters in a local .envrc file, without requiring
   any other configuration files. .envrc files or similar are often already part of a project.
2. How should I manage my personal token?
   Best case: Store it in a password vault (such as GNU pass) and pass it into editmr by e.g. defining an
   alias: `EDITMR_TOKEN=$(pass show editmr-token) editmr`.
   Not-so best case: store it somewhere in your config directory and source it whenever required or put
   it into a local .env file as long as it is git-ignored.
   In any case, just make sure not to push it to remote :)
'

# default values for optional variables:
EDITMR_ENDPOINT=${EDITMR_ENDPOINT:-"https://gitlab.com/api/graphql"}
EDITOR=${EDITOR:-"vim"}

if [[ "$1" == "--help" || "$1" == "-h" ]]; then
	echo "$help_text"
	exit 1
fi

if [ -n "${DEBUG}" ]; then
	set -o xtrace
fi

# check if all required variables have been provided:
if [ ! -n "${EDITMR_TOKEN}" ]; then
	echo "missing EDITMR_TOKEN. Create an access token in your gitlab profile."
	exit 1
fi
if [ ! -n "${EDITMR_PROJECT}" ]; then
	echo "missing EDITMR_PROJECT. See editmr --help for more info"
	exit 1
fi

function get_MR() {
	# Returns a JSON string describing the merge request of the given project
	# and with the given ID.
	#
	# $1: project path
	# $2 branch name of merge request

	local query='query getCurrentMR($project_path: ID!, $branch_name: String!) {
      project(fullPath: $project_path) {
        id
        mergeRequests(sourceBranches: [$branch_name]) {
          nodes {
            iid
            description
          }
        }
      }
    }'

	gq "$EDITMR_ENDPOINT" \
		-H "Authorization: Bearer $EDITMR_TOKEN" \
		-H "Content-Type: application/json" \
		-q "$query" \
		-v "project_path=$1" \
		-v "branch_name=$2"
}

function update_MR() {
	# Updates the description of an MR in the given project and with the given ID.
	#
	# $1 project_path
	# $2 MR IID
	# #3 new description

	local mutation='mutation upate_mr($project_path: ID!, $iid: String!, $desc: String) {
      mergeRequestUpdate(input: {
        projectPath: $project_path,
        description: $desc,
        iid: $iid
      }) {
        mergeRequest {
          description
        }
      }
    }'

	gq "https://gitlab.com/api/graphql" \
		-H "Authorization: Bearer $EDITMR_TOKEN" \
		-H "Content-Type: application/json" \
		-q "$mutation" \
		-v "project_path=$1" \
		-v "iid=\"$2\"" \
		-v "desc=$3"
}

# get all required information about the current merge request:
curr_branch=$(git branch --show-current)
curr_mr=$(get_MR "$EDITMR_PROJECT" "$curr_branch")
mr_iid=$(echo "$curr_mr" | jq -r '.data.project.mergeRequests.nodes[0].iid')

if [[ "$1" == "o" ]]; then
	# Open the current merge request in a browser. Only gitlab.com supported for now.
	xdg-open "https://gitlab.com/$EDITMR_PROJECT/merge_requests/$mr_iid"
	exit 0
fi

# main part of this script.
mr_desc=$(echo "$curr_mr" | jq -r '.data.project.mergeRequests.nodes[0].description')

if [[ "$mr_iid" == "null" ]]; then
	echo "[ERROR]: Could not find the requested merge request."
	printf "Response from endpoint: %s\n" "$curr_mr"
	exit 1
fi

# convert the description to ORG and store it in a temp file
org_desc=$(echo "$mr_desc" | pandoc -f markdown -t org)
target_dir="/tmp/editmr/$EDITMR_PROJECT"
target_file="$target_dir/$(basename $mr_iid).org"
mkdir -p $target_dir
echo "$org_desc" >|$target_file

# open the temp file in an editor and wait for it to return:
$EDITOR $target_file

# if the content of the temp file has been changed,
# convert the content back to markdown and update the MR description:
new_org_desc="$(cat $target_file)"
if [[ "$new_org_desc" == "$org_desc" ]]; then
	echo "no changes detected"
	exit 0
fi

new_md_desc=$(echo "$new_org_desc" | pandoc -f org -t markdown)
update_resp=$(update_MR "$EDITMR_PROJECT" "$mr_iid" "$new_md_desc")

# check if the updates were applied by validating the update response:
actual=$(echo "$update_resp" | jq -r '.data.mergeRequestUpdate.mergeRequest.description')
if [[ "$actual" != "$new_md_desc" ]]; then
	echo "[ERROR]: Is seems that the update has not been applied correctly."
	echo "Expected:"
	echo "$new_md_desc"
	echo "Actual:"
	echo "$actual"
fi
